<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dora.main API documentation</title>
<meta name="description" content="DecoratedMain is the main abstraction used inside Dora.
This defines the core interface that needs to be fullfilled
for Dora to be able to handle an …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dora.main</code></h1>
</header>
<section id="section-intro">
<p>DecoratedMain is the main abstraction used inside Dora.
This defines the core interface that needs to be fullfilled
for Dora to be able to handle an experiment.</p>
<p>This is also where the end user will specify how to launch job, default
Slurm configuration, storage location, naming conventions etc.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Facebook, Inc. and its affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

&#34;&#34;&#34;
DecoratedMain is the main abstraction used inside Dora.
This defines the core interface that needs to be fullfilled
for Dora to be able to handle an experiment.

This is also where the end user will specify how to launch job, default
Slurm configuration, storage location, naming conventions etc.
&#34;&#34;&#34;

import argparse
from collections import OrderedDict
import importlib
import json
from pathlib import Path
import typing as tp
import sys

from .conf import DoraConfig, SlurmConfig
from .names import NamesMixin
from .xp import XP, _context


MainFun = tp.Callable


def _load_main(full_name):
    module_name, fun_name = full_name.rsplit(&#34;.&#34;, 1)
    module = importlib.import_module(module_name)
    return getattr(module, fun_name)


def get_module_name(module):
    if module == &#34;__main__&#34;:
        spec = sys.modules[module].__spec__
        if spec is None:
            return None
        else:
            return spec.name
    else:
        return module


class DecoratedMain(NamesMixin):
    &#34;&#34;&#34;
    Main function that will actually run the XP, wrapped with tons of meta-informations.

    Args:
        main (callable, taking no argument): main function for the experiment as provided
            by the user.
        dora (DoraConfig): configuration for Dora.
    &#34;&#34;&#34;
    _slow = False

    def __init__(self, main: MainFun, dora: DoraConfig):
        self.main = main
        self.dora = dora
        module_name = get_module_name(main.__module__)
        if module_name is None:
            # we are being called in a weird way and definitely not from
            # a Dora command.
            self.package = &#39;unknown&#39;
            self.main_module = &#39;train&#39;
        else:
            if &#39;.&#39; in module_name:
                self.package, self.main_module = module_name.rsplit(&#34;.&#34;, 1)
            else:
                self.package = &#39;unknown&#39;
                self.main_module = module_name

        self.name = self.package
        self._full_name = main.__module__ + &#34;.&#34; + main.__name__

    def __call__(self):
        argv = self._get_argv()
        if not self._is_active(argv):
            return self._main()
        xp = self.get_xp(argv)
        self.init_xp(xp)
        with _context.enter_xp(xp):
            return self._main()

    def _is_active(self, argv: tp.List[str]) -&gt; bool:
        return True

    def _main(self):
        return self.main()

    def __reduce__(self):
        return _load_main, (self._full_name,)

    def get_xp(self, argv: tp.Sequence[str]) -&gt; XP:
        &#34;&#34;&#34;Return an XP given a list of arguments.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def _get_argv(self) -&gt; tp.List[str]:
        # Returns the actual list of arguments, typically from sys.argv.
        # This is only called when the XP is executed, not when it is obtained
        # by other means, e.g. from a grid search file, or info command.
        return sys.argv[1:]

    def init_xp(self, xp: XP):
        &#34;&#34;&#34;
        Initialize the XP folder. Once this is done, the XP can be retrieved
        from its signature. This is done automatically before running,
        or when using the `--init` flag of the `dora grid` command.

        This will also initialize the shared XP folder so that the XP hyper-params
        can be easily shared using its signature.
        &#34;&#34;&#34;
        xp.folder.mkdir(exist_ok=True, parents=True)
        json.dump(xp.argv, open(xp._argv_cache, &#39;w&#39;))
        if xp._shared_argv_cache is not None:
            # Create xps and XP folders with 0777 mode.
            xp._shared_argv_cache.parent.parent.mkdir(exist_ok=True, parents=True, mode=0o777)
            xp._shared_argv_cache.parent.mkdir(exist_ok=True, parents=True, mode=0o777)
            try:
                xp._shared_argv_cache.parent.parent.chmod(0o777)
                xp._shared_argv_cache.parent.chmod(0o777)
            except PermissionError:
                pass
            json.dump(xp.argv, open(xp._shared_argv_cache, &#39;w&#39;))
            try:
                xp._shared_argv_cache.chmod(0o777)
            except PermissionError:
                pass
        return xp

    def get_argv_from_sig(self, sig: str) -&gt; tp.Sequence[str]:
        &#34;&#34;&#34;Returns the argv used to obtain a given signature.
        This can only work if an XP was previously ran with this signature.
        &#34;&#34;&#34;
        xp = XP(sig=sig, dora=self.dora, cfg=None, argv=[])
        if xp._argv_cache.exists():
            return json.load(open(xp._argv_cache))
        elif xp._shared_argv_cache is not None and xp._shared_argv_cache.exists():
            return json.load(open(xp._shared_argv_cache))
        else:
            raise RuntimeError(f&#34;Could not find experiment with signature {sig}&#34;)

    def get_xp_from_sig(self, sig: str) -&gt; XP:
        &#34;&#34;&#34;Returns the XP from the signature. Can only work if such an XP
        has previously ran.
        &#34;&#34;&#34;
        return self.get_xp(self.get_argv_from_sig(sig))

    def __repr__(self):
        return f&#34;DecoratedMain({self.main})&#34;

    def value_to_argv(self, arg: tp.Any) -&gt; tp.List[str]:
        &#34;&#34;&#34;Convert a Python value to argv. arg can be either:
        - a list, then each entry will be converted and all argv are concatenated.
        - a str, then it is directly an argv entry.
        - a dict, then each key, value pair is mapped to an argv entry.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def get_xp_history(self, xp: XP) -&gt; tp.List[dict]:
        &#34;&#34;&#34;Return the metrics for a given XP. By default this will look into
        the `history.json` file, that can be populated with the Link class.

        Can be overriden, but metrics should still be returned as a list
        of dicts, possibly with nested dicts.
        &#34;&#34;&#34;
        xp.link.load()
        return xp.link.history

    def get_slurm_config(self) -&gt; SlurmConfig:
        &#34;&#34;&#34;Return default Slurm config for the launch and grid actions.
        &#34;&#34;&#34;
        return SlurmConfig()


class ArgparseMain(DecoratedMain):
    &#34;&#34;&#34;Implementation of `DecoratedMain` for XP that uses argparse.

    Args:
        main : main function to wrap.
        dora : Dora config, containing the exclude and dir fields.
        parser : parser to use, and to derive default values from.
        slurm : default slurm config for scheduling jobs.
        use_underscore : if False, scheduling a job as `launcher(batch_size=32)`
            will translate to the command-line `--batch-size=32`,
            otherwise, it will stay as `--batch_size=32`.
    &#34;&#34;&#34;
    def __init__(self, main: MainFun, dora: DoraConfig, parser: argparse.ArgumentParser,
                 slurm: tp.Optional[SlurmConfig] = None, use_underscore: bool = True):
        super().__init__(main, dora)
        self.parser = parser
        self.use_underscore = use_underscore
        self.slurm = slurm

    def get_xp(self, argv: tp.Sequence[str]) -&gt; XP:
        argv = list(argv)
        args = self.parser.parse_args(argv)
        delta = []
        for key, value in args.__dict__.items():
            if self.parser.get_default(key) != value:
                delta.append((key, value))
        xp = XP(dora=self.dora, cfg=args, argv=argv, delta=delta)
        return xp

    def value_to_argv(self, arg: tp.Any) -&gt; tp.List[str]:
        argv = []
        if isinstance(arg, str):
            argv.append(arg)
        elif isinstance(arg, dict):
            for key, value in arg.items():
                if not self.use_underscore:
                    key = key.replace(&#34;_&#34;, &#34;-&#34;)
                if value is True:
                    argv.append(f&#34;--{key}&#34;)
                else:
                    argv.append(f&#34;--{key}={value}&#34;)
        elif isinstance(arg, (list, tuple)):
            for part in arg:
                argv += self.value_to_argv(part)
        else:
            raise ValueError(f&#34;Can only process dict, tuple, lists and str, but got {arg}&#34;)
        return argv

    def get_name_parts(self, xp: XP) -&gt; OrderedDict:
        parts = OrderedDict()
        assert xp.delta is not None
        for name, value in xp.delta:
            parts[name] = value
        return parts

    def get_slurm_config(self) -&gt; SlurmConfig:
        &#34;&#34;&#34;Return default Slurm config for the launch and grid actions.
        &#34;&#34;&#34;
        if self.slurm is not None:
            return self.slurm
        return super().get_slurm_config()


def argparse_main(parser: argparse.ArgumentParser, *,
                  dir: tp.Union[str, Path] = &#34;./outputs&#34;,
                  exclude: tp.Sequence[str] = [],
                  slurm: tp.Optional[SlurmConfig] = None,
                  shared: tp.Optional[tp.Union[str, Path]] = None,
                  use_underscore: bool = True,
                  **kwargs):
    &#34;&#34;&#34;Nicer version of `ArgparseMain` that acts like a decorator, and directly
    exposes the most useful configs to override.

    Args:
        parser: parser to use, and to derive default values from.
        exclude: list of patterns of arguments to exclude from the computation
            of the XP signature.
        dir: path to store logs, checkpoints, etc. to.
        slurm: default slurm config for scheduling jobs.
        shared: path to the shared XP repository.
        use_underscore: if False, scheduling a job as `launcher(batch_size=32)`
            will translate to the command-line `--batch-size=32`,
            otherwise, it will stay as `--batch_size=32`.
        **kwargs: extra args are passed to `DoraConfig`.
    &#34;&#34;&#34;
    def _decorator(main: MainFun):
        dora = DoraConfig(
            dir=Path(dir),
            shared=None if shared is None else Path(shared),
            exclude=list(exclude),
            **kwargs)
        return ArgparseMain(main, dora, parser, use_underscore=use_underscore, slurm=slurm)
    return _decorator</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dora.main.argparse_main"><code class="name flex">
<span>def <span class="ident">argparse_main</span></span>(<span>parser: argparse.ArgumentParser, *, dir: Union[str, pathlib.Path] = './outputs', exclude: Sequence[str] = [], slurm: Optional[<a title="dora.conf.SlurmConfig" href="conf.html#dora.conf.SlurmConfig">SlurmConfig</a>] = None, shared: Union[str, pathlib.Path, None] = None, use_underscore: bool = True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Nicer version of <code><a title="dora.main.ArgparseMain" href="#dora.main.ArgparseMain">ArgparseMain</a></code> that acts like a decorator, and directly
exposes the most useful configs to override.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong></dt>
<dd>parser to use, and to derive default values from.</dd>
<dt><strong><code>exclude</code></strong></dt>
<dd>list of patterns of arguments to exclude from the computation
of the XP signature.</dd>
<dt><strong><code>dir</code></strong></dt>
<dd>path to store logs, checkpoints, etc. to.</dd>
<dt><strong><code>slurm</code></strong></dt>
<dd>default slurm config for scheduling jobs.</dd>
<dt><strong><code>shared</code></strong></dt>
<dd>path to the shared XP repository.</dd>
<dt><strong><code>use_underscore</code></strong></dt>
<dd>if False, scheduling a job as <code>launcher(batch_size=32)</code>
will translate to the command-line <code>--batch-size=32</code>,
otherwise, it will stay as <code>--batch_size=32</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>extra args are passed to <code>DoraConfig</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def argparse_main(parser: argparse.ArgumentParser, *,
                  dir: tp.Union[str, Path] = &#34;./outputs&#34;,
                  exclude: tp.Sequence[str] = [],
                  slurm: tp.Optional[SlurmConfig] = None,
                  shared: tp.Optional[tp.Union[str, Path]] = None,
                  use_underscore: bool = True,
                  **kwargs):
    &#34;&#34;&#34;Nicer version of `ArgparseMain` that acts like a decorator, and directly
    exposes the most useful configs to override.

    Args:
        parser: parser to use, and to derive default values from.
        exclude: list of patterns of arguments to exclude from the computation
            of the XP signature.
        dir: path to store logs, checkpoints, etc. to.
        slurm: default slurm config for scheduling jobs.
        shared: path to the shared XP repository.
        use_underscore: if False, scheduling a job as `launcher(batch_size=32)`
            will translate to the command-line `--batch-size=32`,
            otherwise, it will stay as `--batch_size=32`.
        **kwargs: extra args are passed to `DoraConfig`.
    &#34;&#34;&#34;
    def _decorator(main: MainFun):
        dora = DoraConfig(
            dir=Path(dir),
            shared=None if shared is None else Path(shared),
            exclude=list(exclude),
            **kwargs)
        return ArgparseMain(main, dora, parser, use_underscore=use_underscore, slurm=slurm)
    return _decorator</code></pre>
</details>
</dd>
<dt id="dora.main.get_module_name"><code class="name flex">
<span>def <span class="ident">get_module_name</span></span>(<span>module)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_module_name(module):
    if module == &#34;__main__&#34;:
        spec = sys.modules[module].__spec__
        if spec is None:
            return None
        else:
            return spec.name
    else:
        return module</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dora.main.ArgparseMain"><code class="flex name class">
<span>class <span class="ident">ArgparseMain</span></span>
<span>(</span><span>main: Callable, dora: <a title="dora.conf.DoraConfig" href="conf.html#dora.conf.DoraConfig">DoraConfig</a>, parser: argparse.ArgumentParser, slurm: Optional[<a title="dora.conf.SlurmConfig" href="conf.html#dora.conf.SlurmConfig">SlurmConfig</a>] = None, use_underscore: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of <code><a title="dora.main.DecoratedMain" href="#dora.main.DecoratedMain">DecoratedMain</a></code> for XP that uses argparse.</p>
<h2 id="args">Args</h2>
<p>main : main function to wrap.
dora : Dora config, containing the exclude and dir fields.
parser : parser to use, and to derive default values from.
slurm : default slurm config for scheduling jobs.
use_underscore : if False, scheduling a job as <code>launcher(batch_size=32)</code>
will translate to the command-line <code>--batch-size=32</code>,
otherwise, it will stay as <code>--batch_size=32</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArgparseMain(DecoratedMain):
    &#34;&#34;&#34;Implementation of `DecoratedMain` for XP that uses argparse.

    Args:
        main : main function to wrap.
        dora : Dora config, containing the exclude and dir fields.
        parser : parser to use, and to derive default values from.
        slurm : default slurm config for scheduling jobs.
        use_underscore : if False, scheduling a job as `launcher(batch_size=32)`
            will translate to the command-line `--batch-size=32`,
            otherwise, it will stay as `--batch_size=32`.
    &#34;&#34;&#34;
    def __init__(self, main: MainFun, dora: DoraConfig, parser: argparse.ArgumentParser,
                 slurm: tp.Optional[SlurmConfig] = None, use_underscore: bool = True):
        super().__init__(main, dora)
        self.parser = parser
        self.use_underscore = use_underscore
        self.slurm = slurm

    def get_xp(self, argv: tp.Sequence[str]) -&gt; XP:
        argv = list(argv)
        args = self.parser.parse_args(argv)
        delta = []
        for key, value in args.__dict__.items():
            if self.parser.get_default(key) != value:
                delta.append((key, value))
        xp = XP(dora=self.dora, cfg=args, argv=argv, delta=delta)
        return xp

    def value_to_argv(self, arg: tp.Any) -&gt; tp.List[str]:
        argv = []
        if isinstance(arg, str):
            argv.append(arg)
        elif isinstance(arg, dict):
            for key, value in arg.items():
                if not self.use_underscore:
                    key = key.replace(&#34;_&#34;, &#34;-&#34;)
                if value is True:
                    argv.append(f&#34;--{key}&#34;)
                else:
                    argv.append(f&#34;--{key}={value}&#34;)
        elif isinstance(arg, (list, tuple)):
            for part in arg:
                argv += self.value_to_argv(part)
        else:
            raise ValueError(f&#34;Can only process dict, tuple, lists and str, but got {arg}&#34;)
        return argv

    def get_name_parts(self, xp: XP) -&gt; OrderedDict:
        parts = OrderedDict()
        assert xp.delta is not None
        for name, value in xp.delta:
            parts[name] = value
        return parts

    def get_slurm_config(self) -&gt; SlurmConfig:
        &#34;&#34;&#34;Return default Slurm config for the launch and grid actions.
        &#34;&#34;&#34;
        if self.slurm is not None:
            return self.slurm
        return super().get_slurm_config()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dora.main.DecoratedMain" href="#dora.main.DecoratedMain">DecoratedMain</a></li>
<li><a title="dora.names.NamesMixin" href="names.html#dora.names.NamesMixin">NamesMixin</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dora.main.DecoratedMain" href="#dora.main.DecoratedMain">DecoratedMain</a></b></code>:
<ul class="hlist">
<li><code><a title="dora.main.DecoratedMain.get_argv_from_sig" href="#dora.main.DecoratedMain.get_argv_from_sig">get_argv_from_sig</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_name" href="names.html#dora.names.NamesMixin.get_name">get_name</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_name_parts" href="names.html#dora.names.NamesMixin.get_name_parts">get_name_parts</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_names" href="names.html#dora.names.NamesMixin.get_names">get_names</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_slurm_config" href="#dora.main.DecoratedMain.get_slurm_config">get_slurm_config</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_xp" href="#dora.main.DecoratedMain.get_xp">get_xp</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_xp_from_sig" href="#dora.main.DecoratedMain.get_xp_from_sig">get_xp_from_sig</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_xp_history" href="#dora.main.DecoratedMain.get_xp_history">get_xp_history</a></code></li>
<li><code><a title="dora.main.DecoratedMain.init_xp" href="#dora.main.DecoratedMain.init_xp">init_xp</a></code></li>
<li><code><a title="dora.main.DecoratedMain.short_name_part" href="names.html#dora.names.NamesMixin.short_name_part">short_name_part</a></code></li>
<li><code><a title="dora.main.DecoratedMain.value_to_argv" href="#dora.main.DecoratedMain.value_to_argv">value_to_argv</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dora.main.DecoratedMain"><code class="flex name class">
<span>class <span class="ident">DecoratedMain</span></span>
<span>(</span><span>main: Callable, dora: <a title="dora.conf.DoraConfig" href="conf.html#dora.conf.DoraConfig">DoraConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function that will actually run the XP, wrapped with tons of meta-informations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>main</code></strong> :&ensp;<code>callable, taking no argument</code></dt>
<dd>main function for the experiment as provided
by the user.</dd>
<dt><strong><code>dora</code></strong> :&ensp;<code>DoraConfig</code></dt>
<dd>configuration for Dora.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DecoratedMain(NamesMixin):
    &#34;&#34;&#34;
    Main function that will actually run the XP, wrapped with tons of meta-informations.

    Args:
        main (callable, taking no argument): main function for the experiment as provided
            by the user.
        dora (DoraConfig): configuration for Dora.
    &#34;&#34;&#34;
    _slow = False

    def __init__(self, main: MainFun, dora: DoraConfig):
        self.main = main
        self.dora = dora
        module_name = get_module_name(main.__module__)
        if module_name is None:
            # we are being called in a weird way and definitely not from
            # a Dora command.
            self.package = &#39;unknown&#39;
            self.main_module = &#39;train&#39;
        else:
            if &#39;.&#39; in module_name:
                self.package, self.main_module = module_name.rsplit(&#34;.&#34;, 1)
            else:
                self.package = &#39;unknown&#39;
                self.main_module = module_name

        self.name = self.package
        self._full_name = main.__module__ + &#34;.&#34; + main.__name__

    def __call__(self):
        argv = self._get_argv()
        if not self._is_active(argv):
            return self._main()
        xp = self.get_xp(argv)
        self.init_xp(xp)
        with _context.enter_xp(xp):
            return self._main()

    def _is_active(self, argv: tp.List[str]) -&gt; bool:
        return True

    def _main(self):
        return self.main()

    def __reduce__(self):
        return _load_main, (self._full_name,)

    def get_xp(self, argv: tp.Sequence[str]) -&gt; XP:
        &#34;&#34;&#34;Return an XP given a list of arguments.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def _get_argv(self) -&gt; tp.List[str]:
        # Returns the actual list of arguments, typically from sys.argv.
        # This is only called when the XP is executed, not when it is obtained
        # by other means, e.g. from a grid search file, or info command.
        return sys.argv[1:]

    def init_xp(self, xp: XP):
        &#34;&#34;&#34;
        Initialize the XP folder. Once this is done, the XP can be retrieved
        from its signature. This is done automatically before running,
        or when using the `--init` flag of the `dora grid` command.

        This will also initialize the shared XP folder so that the XP hyper-params
        can be easily shared using its signature.
        &#34;&#34;&#34;
        xp.folder.mkdir(exist_ok=True, parents=True)
        json.dump(xp.argv, open(xp._argv_cache, &#39;w&#39;))
        if xp._shared_argv_cache is not None:
            # Create xps and XP folders with 0777 mode.
            xp._shared_argv_cache.parent.parent.mkdir(exist_ok=True, parents=True, mode=0o777)
            xp._shared_argv_cache.parent.mkdir(exist_ok=True, parents=True, mode=0o777)
            try:
                xp._shared_argv_cache.parent.parent.chmod(0o777)
                xp._shared_argv_cache.parent.chmod(0o777)
            except PermissionError:
                pass
            json.dump(xp.argv, open(xp._shared_argv_cache, &#39;w&#39;))
            try:
                xp._shared_argv_cache.chmod(0o777)
            except PermissionError:
                pass
        return xp

    def get_argv_from_sig(self, sig: str) -&gt; tp.Sequence[str]:
        &#34;&#34;&#34;Returns the argv used to obtain a given signature.
        This can only work if an XP was previously ran with this signature.
        &#34;&#34;&#34;
        xp = XP(sig=sig, dora=self.dora, cfg=None, argv=[])
        if xp._argv_cache.exists():
            return json.load(open(xp._argv_cache))
        elif xp._shared_argv_cache is not None and xp._shared_argv_cache.exists():
            return json.load(open(xp._shared_argv_cache))
        else:
            raise RuntimeError(f&#34;Could not find experiment with signature {sig}&#34;)

    def get_xp_from_sig(self, sig: str) -&gt; XP:
        &#34;&#34;&#34;Returns the XP from the signature. Can only work if such an XP
        has previously ran.
        &#34;&#34;&#34;
        return self.get_xp(self.get_argv_from_sig(sig))

    def __repr__(self):
        return f&#34;DecoratedMain({self.main})&#34;

    def value_to_argv(self, arg: tp.Any) -&gt; tp.List[str]:
        &#34;&#34;&#34;Convert a Python value to argv. arg can be either:
        - a list, then each entry will be converted and all argv are concatenated.
        - a str, then it is directly an argv entry.
        - a dict, then each key, value pair is mapped to an argv entry.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def get_xp_history(self, xp: XP) -&gt; tp.List[dict]:
        &#34;&#34;&#34;Return the metrics for a given XP. By default this will look into
        the `history.json` file, that can be populated with the Link class.

        Can be overriden, but metrics should still be returned as a list
        of dicts, possibly with nested dicts.
        &#34;&#34;&#34;
        xp.link.load()
        return xp.link.history

    def get_slurm_config(self) -&gt; SlurmConfig:
        &#34;&#34;&#34;Return default Slurm config for the launch and grid actions.
        &#34;&#34;&#34;
        return SlurmConfig()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dora.names.NamesMixin" href="names.html#dora.names.NamesMixin">NamesMixin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dora.hydra.HydraMain" href="hydra.html#dora.hydra.HydraMain">HydraMain</a></li>
<li><a title="dora.main.ArgparseMain" href="#dora.main.ArgparseMain">ArgparseMain</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dora.main.DecoratedMain.get_argv_from_sig"><code class="name flex">
<span>def <span class="ident">get_argv_from_sig</span></span>(<span>self, sig: str) ‑> Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the argv used to obtain a given signature.
This can only work if an XP was previously ran with this signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_argv_from_sig(self, sig: str) -&gt; tp.Sequence[str]:
    &#34;&#34;&#34;Returns the argv used to obtain a given signature.
    This can only work if an XP was previously ran with this signature.
    &#34;&#34;&#34;
    xp = XP(sig=sig, dora=self.dora, cfg=None, argv=[])
    if xp._argv_cache.exists():
        return json.load(open(xp._argv_cache))
    elif xp._shared_argv_cache is not None and xp._shared_argv_cache.exists():
        return json.load(open(xp._shared_argv_cache))
    else:
        raise RuntimeError(f&#34;Could not find experiment with signature {sig}&#34;)</code></pre>
</details>
</dd>
<dt id="dora.main.DecoratedMain.get_slurm_config"><code class="name flex">
<span>def <span class="ident">get_slurm_config</span></span>(<span>self) ‑> <a title="dora.conf.SlurmConfig" href="conf.html#dora.conf.SlurmConfig">SlurmConfig</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return default Slurm config for the launch and grid actions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slurm_config(self) -&gt; SlurmConfig:
    &#34;&#34;&#34;Return default Slurm config for the launch and grid actions.
    &#34;&#34;&#34;
    return SlurmConfig()</code></pre>
</details>
</dd>
<dt id="dora.main.DecoratedMain.get_xp"><code class="name flex">
<span>def <span class="ident">get_xp</span></span>(<span>self, argv: Sequence[str]) ‑> <a title="dora.xp.XP" href="xp.html#dora.xp.XP">XP</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return an XP given a list of arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xp(self, argv: tp.Sequence[str]) -&gt; XP:
    &#34;&#34;&#34;Return an XP given a list of arguments.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="dora.main.DecoratedMain.get_xp_from_sig"><code class="name flex">
<span>def <span class="ident">get_xp_from_sig</span></span>(<span>self, sig: str) ‑> <a title="dora.xp.XP" href="xp.html#dora.xp.XP">XP</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the XP from the signature. Can only work if such an XP
has previously ran.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xp_from_sig(self, sig: str) -&gt; XP:
    &#34;&#34;&#34;Returns the XP from the signature. Can only work if such an XP
    has previously ran.
    &#34;&#34;&#34;
    return self.get_xp(self.get_argv_from_sig(sig))</code></pre>
</details>
</dd>
<dt id="dora.main.DecoratedMain.get_xp_history"><code class="name flex">
<span>def <span class="ident">get_xp_history</span></span>(<span>self, xp: <a title="dora.xp.XP" href="xp.html#dora.xp.XP">XP</a>) ‑> List[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the metrics for a given XP. By default this will look into
the <code>history.json</code> file, that can be populated with the Link class.</p>
<p>Can be overriden, but metrics should still be returned as a list
of dicts, possibly with nested dicts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xp_history(self, xp: XP) -&gt; tp.List[dict]:
    &#34;&#34;&#34;Return the metrics for a given XP. By default this will look into
    the `history.json` file, that can be populated with the Link class.

    Can be overriden, but metrics should still be returned as a list
    of dicts, possibly with nested dicts.
    &#34;&#34;&#34;
    xp.link.load()
    return xp.link.history</code></pre>
</details>
</dd>
<dt id="dora.main.DecoratedMain.init_xp"><code class="name flex">
<span>def <span class="ident">init_xp</span></span>(<span>self, xp: <a title="dora.xp.XP" href="xp.html#dora.xp.XP">XP</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the XP folder. Once this is done, the XP can be retrieved
from its signature. This is done automatically before running,
or when using the <code>--init</code> flag of the <code><a title="dora" href="index.html">dora</a> grid</code> command.</p>
<p>This will also initialize the shared XP folder so that the XP hyper-params
can be easily shared using its signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_xp(self, xp: XP):
    &#34;&#34;&#34;
    Initialize the XP folder. Once this is done, the XP can be retrieved
    from its signature. This is done automatically before running,
    or when using the `--init` flag of the `dora grid` command.

    This will also initialize the shared XP folder so that the XP hyper-params
    can be easily shared using its signature.
    &#34;&#34;&#34;
    xp.folder.mkdir(exist_ok=True, parents=True)
    json.dump(xp.argv, open(xp._argv_cache, &#39;w&#39;))
    if xp._shared_argv_cache is not None:
        # Create xps and XP folders with 0777 mode.
        xp._shared_argv_cache.parent.parent.mkdir(exist_ok=True, parents=True, mode=0o777)
        xp._shared_argv_cache.parent.mkdir(exist_ok=True, parents=True, mode=0o777)
        try:
            xp._shared_argv_cache.parent.parent.chmod(0o777)
            xp._shared_argv_cache.parent.chmod(0o777)
        except PermissionError:
            pass
        json.dump(xp.argv, open(xp._shared_argv_cache, &#39;w&#39;))
        try:
            xp._shared_argv_cache.chmod(0o777)
        except PermissionError:
            pass
    return xp</code></pre>
</details>
</dd>
<dt id="dora.main.DecoratedMain.value_to_argv"><code class="name flex">
<span>def <span class="ident">value_to_argv</span></span>(<span>self, arg: Any) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a Python value to argv. arg can be either:
- a list, then each entry will be converted and all argv are concatenated.
- a str, then it is directly an argv entry.
- a dict, then each key, value pair is mapped to an argv entry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def value_to_argv(self, arg: tp.Any) -&gt; tp.List[str]:
    &#34;&#34;&#34;Convert a Python value to argv. arg can be either:
    - a list, then each entry will be converted and all argv are concatenated.
    - a str, then it is directly an argv entry.
    - a dict, then each key, value pair is mapped to an argv entry.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dora.names.NamesMixin" href="names.html#dora.names.NamesMixin">NamesMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="dora.names.NamesMixin.get_name" href="names.html#dora.names.NamesMixin.get_name">get_name</a></code></li>
<li><code><a title="dora.names.NamesMixin.get_name_parts" href="names.html#dora.names.NamesMixin.get_name_parts">get_name_parts</a></code></li>
<li><code><a title="dora.names.NamesMixin.get_names" href="names.html#dora.names.NamesMixin.get_names">get_names</a></code></li>
<li><code><a title="dora.names.NamesMixin.short_name_part" href="names.html#dora.names.NamesMixin.short_name_part">short_name_part</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dora" href="index.html">dora</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dora.main.argparse_main" href="#dora.main.argparse_main">argparse_main</a></code></li>
<li><code><a title="dora.main.get_module_name" href="#dora.main.get_module_name">get_module_name</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dora.main.ArgparseMain" href="#dora.main.ArgparseMain">ArgparseMain</a></code></h4>
</li>
<li>
<h4><code><a title="dora.main.DecoratedMain" href="#dora.main.DecoratedMain">DecoratedMain</a></code></h4>
<ul class="two-column">
<li><code><a title="dora.main.DecoratedMain.get_argv_from_sig" href="#dora.main.DecoratedMain.get_argv_from_sig">get_argv_from_sig</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_slurm_config" href="#dora.main.DecoratedMain.get_slurm_config">get_slurm_config</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_xp" href="#dora.main.DecoratedMain.get_xp">get_xp</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_xp_from_sig" href="#dora.main.DecoratedMain.get_xp_from_sig">get_xp_from_sig</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_xp_history" href="#dora.main.DecoratedMain.get_xp_history">get_xp_history</a></code></li>
<li><code><a title="dora.main.DecoratedMain.init_xp" href="#dora.main.DecoratedMain.init_xp">init_xp</a></code></li>
<li><code><a title="dora.main.DecoratedMain.value_to_argv" href="#dora.main.DecoratedMain.value_to_argv">value_to_argv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>