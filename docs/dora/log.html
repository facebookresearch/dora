<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dora.log API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dora.log</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Facebook, Inc. and its affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

from collections.abc import Iterable, Sized
import logging
import sys
import time
import typing as tp

from treetable.text import colorize


class LogProgress:
    &#34;&#34;&#34;
    Sort of like tqdm but using log lines and not as real time.
    Args:
        - logger: logger obtained from `logging.getLogger`,
        - iterable: iterable object to wrap
        - updates (int): number of lines that will be printed, e.g.
            if `updates=5`, log every 1/5th of the total length.
        - time_per_it (bool): force speed to display as ms/it
        - total (int): length of the iterable, in case it does not support
            `len`.
        - name (str): prefix to use in the log.
        - level: logging level (like `logging.INFO`).
    &#34;&#34;&#34;
    def __init__(self,
                 logger: logging.Logger,
                 iterable: Iterable,
                 updates: int = 5,
                 min_interval: int = 1,
                 time_per_it: bool = False,
                 total: tp.Optional[int] = None,
                 name: str = &#34;LogProgress&#34;,
                 level: int = logging.INFO):
        self.iterable = iterable
        if total is None:
            assert isinstance(iterable, Sized)
            total = len(iterable)
        self.total = total
        self.updates = updates
        self.min_interval = min_interval
        self.time_per_it = time_per_it
        self.name = name
        self.logger = logger
        self.level = level

    def update(self, **infos) -&gt; bool:
        &#34;&#34;&#34;Update the metrics to show when logging. Return True if logging will
        happen at the end of this iteration.&#34;&#34;&#34;
        self._infos = infos
        return self._will_log

    def __iter__(self):
        self._iterator = iter(self.iterable)
        self._will_log = False
        self._index = -1
        self._infos = {}
        self._begin = time.time()
        return self

    def __next__(self):
        if self._will_log:
            self._log()
            self._will_log = False
        try:
            value = next(self._iterator)
        except StopIteration:
            raise
        else:
            self._index += 1
            if self.updates &gt; 0:
                log_every = max(self.min_interval, self.total // self.updates)
                # logging is delayed by 1 it, in order to have the metrics from update
                if self._index &gt;= 1 and self._index % log_every == 0:
                    self._will_log = True
            return value

    def _log(self):
        self._speed = (1 + self._index) / (time.time() - self._begin)
        infos = &#34; | &#34;.join(f&#34;{k.capitalize()} {v}&#34; for k, v in self._infos.items())
        if self._speed &lt; 1e-4:
            speed = &#34;oo sec/it&#34;
        elif self.time_per_it and self._speed &lt; 1:
            speed = f&#34;{1 / self._speed:.2f} sec/it&#34;
        elif self.time_per_it:
            speed = f&#34;{1000 / self._speed:.1f} ms/it&#34;
        elif self._speed &lt; 0.1:
            speed = f&#34;{1/self._speed:.1f} sec/it&#34;
        else:
            speed = f&#34;{self._speed:.2f} it/sec&#34;
        out = f&#34;{self.name} | {self._index}/{self.total} | {speed}&#34;
        if infos:
            out += &#34; | &#34; + infos
        self.logger.log(self.level, out)


def bold(text: str) -&gt; str:
    &#34;&#34;&#34;
    Display text in bold in the terminal.
    &#34;&#34;&#34;
    return colorize(text, &#34;1&#34;)


def red(text: str) -&gt; str:
    &#34;&#34;&#34;Display text in red.
    &#34;&#34;&#34;
    # see https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences
    return colorize(text, &#34;31&#34;)


def simple_log(first: str, *args, color=None):
    print(bold(first), *args, file=sys.stderr)


def fatal(*args) -&gt; tp.NoReturn:
    simple_log(&#34;FATAL:&#34;, *args)
    sys.exit(1)


_dora_handler = None


def setup_logging(verbose=False):
    global _dora_handler  # I know this is dirty
    log_level = logging.DEBUG if verbose else logging.INFO
    logger = logging.getLogger(&#39;dora&#39;)
    logger.setLevel(log_level)
    _dora_handler = logging.StreamHandler(sys.stderr)
    _dora_handler.setFormatter(logging.Formatter(&#39;%(levelname)s:%(name)s:%(message)s&#39;))
    _dora_handler.setLevel(log_level)
    logger.addHandler(_dora_handler)


def disable_logging():
    assert _dora_handler is not None
    logger = logging.getLogger(&#39;dora&#39;)
    logger.removeHandler(_dora_handler)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dora.log.bold"><code class="name flex">
<span>def <span class="ident">bold</span></span>(<span>text: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Display text in bold in the terminal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bold(text: str) -&gt; str:
    &#34;&#34;&#34;
    Display text in bold in the terminal.
    &#34;&#34;&#34;
    return colorize(text, &#34;1&#34;)</code></pre>
</details>
</dd>
<dt id="dora.log.disable_logging"><code class="name flex">
<span>def <span class="ident">disable_logging</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_logging():
    assert _dora_handler is not None
    logger = logging.getLogger(&#39;dora&#39;)
    logger.removeHandler(_dora_handler)</code></pre>
</details>
</dd>
<dt id="dora.log.fatal"><code class="name flex">
<span>def <span class="ident">fatal</span></span>(<span>*args) ‑> NoReturn</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fatal(*args) -&gt; tp.NoReturn:
    simple_log(&#34;FATAL:&#34;, *args)
    sys.exit(1)</code></pre>
</details>
</dd>
<dt id="dora.log.red"><code class="name flex">
<span>def <span class="ident">red</span></span>(<span>text: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Display text in red.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def red(text: str) -&gt; str:
    &#34;&#34;&#34;Display text in red.
    &#34;&#34;&#34;
    # see https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences
    return colorize(text, &#34;31&#34;)</code></pre>
</details>
</dd>
<dt id="dora.log.setup_logging"><code class="name flex">
<span>def <span class="ident">setup_logging</span></span>(<span>verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_logging(verbose=False):
    global _dora_handler  # I know this is dirty
    log_level = logging.DEBUG if verbose else logging.INFO
    logger = logging.getLogger(&#39;dora&#39;)
    logger.setLevel(log_level)
    _dora_handler = logging.StreamHandler(sys.stderr)
    _dora_handler.setFormatter(logging.Formatter(&#39;%(levelname)s:%(name)s:%(message)s&#39;))
    _dora_handler.setLevel(log_level)
    logger.addHandler(_dora_handler)</code></pre>
</details>
</dd>
<dt id="dora.log.simple_log"><code class="name flex">
<span>def <span class="ident">simple_log</span></span>(<span>first: str, *args, color=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_log(first: str, *args, color=None):
    print(bold(first), *args, file=sys.stderr)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dora.log.LogProgress"><code class="flex name class">
<span>class <span class="ident">LogProgress</span></span>
<span>(</span><span>logger: logging.Logger, iterable: collections.abc.Iterable, updates: int = 5, min_interval: int = 1, time_per_it: bool = False, total: Optional[int] = None, name: str = 'LogProgress', level: int = 20)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort of like tqdm but using log lines and not as real time.</p>
<h2 id="args">Args</h2>
<ul>
<li>logger: logger obtained from <code>logging.getLogger</code>,</li>
<li>iterable: iterable object to wrap</li>
<li>updates (int): number of lines that will be printed, e.g.
if <code>updates=5</code>, log every 1/5th of the total length.</li>
<li>time_per_it (bool): force speed to display as ms/it</li>
<li>total (int): length of the iterable, in case it does not support
<code>len</code>.</li>
<li>name (str): prefix to use in the log.</li>
<li>level: logging level (like <code>logging.INFO</code>).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogProgress:
    &#34;&#34;&#34;
    Sort of like tqdm but using log lines and not as real time.
    Args:
        - logger: logger obtained from `logging.getLogger`,
        - iterable: iterable object to wrap
        - updates (int): number of lines that will be printed, e.g.
            if `updates=5`, log every 1/5th of the total length.
        - time_per_it (bool): force speed to display as ms/it
        - total (int): length of the iterable, in case it does not support
            `len`.
        - name (str): prefix to use in the log.
        - level: logging level (like `logging.INFO`).
    &#34;&#34;&#34;
    def __init__(self,
                 logger: logging.Logger,
                 iterable: Iterable,
                 updates: int = 5,
                 min_interval: int = 1,
                 time_per_it: bool = False,
                 total: tp.Optional[int] = None,
                 name: str = &#34;LogProgress&#34;,
                 level: int = logging.INFO):
        self.iterable = iterable
        if total is None:
            assert isinstance(iterable, Sized)
            total = len(iterable)
        self.total = total
        self.updates = updates
        self.min_interval = min_interval
        self.time_per_it = time_per_it
        self.name = name
        self.logger = logger
        self.level = level

    def update(self, **infos) -&gt; bool:
        &#34;&#34;&#34;Update the metrics to show when logging. Return True if logging will
        happen at the end of this iteration.&#34;&#34;&#34;
        self._infos = infos
        return self._will_log

    def __iter__(self):
        self._iterator = iter(self.iterable)
        self._will_log = False
        self._index = -1
        self._infos = {}
        self._begin = time.time()
        return self

    def __next__(self):
        if self._will_log:
            self._log()
            self._will_log = False
        try:
            value = next(self._iterator)
        except StopIteration:
            raise
        else:
            self._index += 1
            if self.updates &gt; 0:
                log_every = max(self.min_interval, self.total // self.updates)
                # logging is delayed by 1 it, in order to have the metrics from update
                if self._index &gt;= 1 and self._index % log_every == 0:
                    self._will_log = True
            return value

    def _log(self):
        self._speed = (1 + self._index) / (time.time() - self._begin)
        infos = &#34; | &#34;.join(f&#34;{k.capitalize()} {v}&#34; for k, v in self._infos.items())
        if self._speed &lt; 1e-4:
            speed = &#34;oo sec/it&#34;
        elif self.time_per_it and self._speed &lt; 1:
            speed = f&#34;{1 / self._speed:.2f} sec/it&#34;
        elif self.time_per_it:
            speed = f&#34;{1000 / self._speed:.1f} ms/it&#34;
        elif self._speed &lt; 0.1:
            speed = f&#34;{1/self._speed:.1f} sec/it&#34;
        else:
            speed = f&#34;{self._speed:.2f} it/sec&#34;
        out = f&#34;{self.name} | {self._index}/{self.total} | {speed}&#34;
        if infos:
            out += &#34; | &#34; + infos
        self.logger.log(self.level, out)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dora.log.LogProgress.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **infos) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Update the metrics to show when logging. Return True if logging will
happen at the end of this iteration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **infos) -&gt; bool:
    &#34;&#34;&#34;Update the metrics to show when logging. Return True if logging will
    happen at the end of this iteration.&#34;&#34;&#34;
    self._infos = infos
    return self._will_log</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dora" href="index.html">dora</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="dora.log.bold" href="#dora.log.bold">bold</a></code></li>
<li><code><a title="dora.log.disable_logging" href="#dora.log.disable_logging">disable_logging</a></code></li>
<li><code><a title="dora.log.fatal" href="#dora.log.fatal">fatal</a></code></li>
<li><code><a title="dora.log.red" href="#dora.log.red">red</a></code></li>
<li><code><a title="dora.log.setup_logging" href="#dora.log.setup_logging">setup_logging</a></code></li>
<li><code><a title="dora.log.simple_log" href="#dora.log.simple_log">simple_log</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dora.log.LogProgress" href="#dora.log.LogProgress">LogProgress</a></code></h4>
<ul class="">
<li><code><a title="dora.log.LogProgress.update" href="#dora.log.LogProgress.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>