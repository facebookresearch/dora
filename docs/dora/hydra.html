<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dora.hydra API documentation</title>
<meta name="description" content="This module provides support for Hydra, in particular the `main` wrapper between
the end user `main` function and Hydra." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dora.hydra</code></h1>
</header>
<section id="section-intro">
<p>This module provides support for Hydra, in particular the <code>main</code> wrapper between
the end user <code>main</code> function and Hydra.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Facebook, Inc. and its affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

&#34;&#34;&#34;
This module provides support for Hydra, in particular the `main` wrapper between
the end user `main` function and Hydra.
&#34;&#34;&#34;
import copy
from collections import namedtuple, OrderedDict
from importlib.util import find_spec
import json
import logging
from pathlib import Path
import sys
import typing as tp
from unittest import mock

import hydra
from hydra.core.global_hydra import GlobalHydra
try:
    from hydra import compose, initialize_config_dir  # type: ignore
except ImportError:
    from hydra.experimental import compose, initialize_config_dir  # type: ignore
    old_hydra = True
else:
    old_hydra = False

from omegaconf.dictconfig import DictConfig

from .conf import DoraConfig, SlurmConfig, update_from_hydra
from .main import DecoratedMain, MainFun
from .xp import XP, get_xp, is_xp

logger = logging.getLogger(__name__)


def _no_copy(self: tp.Any, memo: tp.Any):
    # Dirty trick to speed up Hydra, will remove when Hydra 1.1
    # is released, which solves the issues.
    return self


_Difference = namedtuple(&#34;_Difference&#34;, &#34;path key ref other ref_value other_value&#34;)


class _NotThere:
    pass


NotThere = _NotThere()


def _compare_config(ref, other, path=[]):
    &#34;&#34;&#34;
    Given two configs, gives an iterator over all the differences. For each difference,
    this will give a _Difference namedtuple.
    &#34;&#34;&#34;
    keys = sorted(ref.keys())
    remaining = sorted(set(other.keys()) - set(ref.keys()))
    delta = []
    path.append(None)
    for key in keys:
        path[-1] = key
        ref_value = ref[key]
        assert key in other, f&#34;XP config shouldn&#39;t be missing any key. Missing key {key}&#34;
        other_value = other[key]

        if isinstance(ref_value, DictConfig):
            assert isinstance(other_value, DictConfig), \
                &#34;Structure of config should be identical between XPs. &#34;\
                f&#34;Wrong type for {key}, expected DictConfig, got {type(other_value)}.&#34;
            yield from _compare_config(ref_value, other_value, path)
        elif other_value != ref_value:
            yield _Difference(list(path), key, ref, other, ref_value, other_value)

    for key in remaining:
        path[-1] = key
        other_value = other[key]
        yield _Difference(list(path), key, ref, other, NotThere, other_value)
    path.pop(-1)
    return delta


def _simplify_argv(argv: tp.Sequence[str]) -&gt; tp.List[str]:
    simplified = []
    seen = set()
    for arg in list(argv)[::-1]:
        assert &#39;=&#39; in arg, f&#39;Argument {arg} does not contain =&#39;
        key, value = arg.split(&#39;=&#39;, 1)
        key = key.strip()
        if key in seen:
            continue
        else:
            seen.add(key)
            simplified.append(arg)
    return simplified[::-1]


def _dump_key(key):
    if key is None:
        return &#34;null&#34;
    elif isinstance(key, (bool, int, float)):
        return str(key)
    elif isinstance(key, str):
        assert &#34;:&#34; not in key
        return key
    else:
        raise TypeError(f&#34;Unsupported dict key type {type(key)} for key {key}&#34;)


def _hydra_value_as_override(value):
    # hydra doesn&#39;t support parsing dict with the json format, so for now
    # we have to use a custom function to dump a value.
    if value is None:
        return &#34;null&#34;
    elif isinstance(value, (bool, int, float, str)):
        return json.dumps(value)
    elif isinstance(value, dict):
        return &#34;{&#34; + &#34;, &#34;.join(
            f&#34;{_dump_key(key)}: {_hydra_value_as_override(val)}&#34;
            for key, val in value.items()
        ) + &#34;}&#34;
    elif isinstance(value, (list, tuple)):
        return &#34;[&#34; + &#34;, &#34;.join(_hydra_value_as_override(val) for val in value) + &#34;]&#34;
    else:
        raise TypeError(f&#34;Unsupported value type {type(value)} for value {value}&#34;)


class HydraMain(DecoratedMain):
    _slow = True

    def __init__(self, main: MainFun, config_name: str, config_path: str, **kwargs):
        self.config_name = config_name
        self.config_path = config_path
        self.hydra_kwargs = kwargs

        module = main.__module__
        if module == &#34;__main__&#34;:
            spec = sys.modules[module].__spec__
            if spec is None:
                module_path = sys.argv[0]
                self._job_name = module_path.rsplit(&#34;.&#34;, 2)[1]
            else:
                assert spec.origin is not None
                module_path = spec.origin
                module = spec.name
                self._job_name = module.rsplit(&#34;.&#34;, 1)[1]
        else:
            spec = find_spec(module)
            assert spec is not None and spec.origin is not None
            module_path = spec.origin
            self._job_name = module.rsplit(&#34;.&#34;, 1)[1]
        self.full_config_path = Path(module_path).parent.resolve()
        if config_path is not None:
            self.full_config_path = self.full_config_path / config_path

        self._initialized = False
        self._base_cfg = self._get_config()
        self._config_groups = self._get_config_groups()
        dora = self._get_dora()
        super().__init__(main, dora)
        # this is a really dirty hack to make Hydra believe that this is
        # coming from the __main__ module, as it would usually be.
        # This allows to use relative paths for config_path.
        main.__module__ = &#34;__main__&#34;

    def _get_dora(self) -&gt; DoraConfig:
        dora = DoraConfig()
        if hasattr(self._base_cfg, &#34;dora&#34;):
            update_from_hydra(dora, self._base_cfg.dora)
        dora.exclude += [&#34;dora.*&#34;, &#34;slurm.*&#34;]
        dora.dir = Path(dora.dir)
        return dora

    def get_slurm_config(self) -&gt; SlurmConfig:
        &#34;&#34;&#34;Return default Slurm config for the launch and grid actions.
        &#34;&#34;&#34;
        slurm = SlurmConfig()
        if hasattr(self._base_cfg, &#34;slurm&#34;):
            update_from_hydra(slurm, self._base_cfg.slurm)
        return slurm

    def get_xp(self, argv: tp.Sequence[str]):
        argv = _simplify_argv(argv)
        cfg = self._get_config(argv)
        base, delta = self._get_base_config(argv)
        delta += self._get_delta(base, cfg)
        xp = XP(dora=self.dora, cfg=cfg, argv=argv, delta=delta)
        return xp

    def value_to_argv(self, arg: tp.Any) -&gt; tp.List[str]:
        # Here we get the raw stuff from what is passed to the grid launcher.
        # arg is either a str (in which case it is a raw override)
        # or a dict, in which case each entry is an override,
        # or a list of dict or a list of str.
        argv = []
        if isinstance(arg, str):
            argv.append(arg)
        elif isinstance(arg, dict):
            for key, value in arg.items():
                if key not in self._config_groups:
                    # We need to convert the value using a custom function
                    # to respect how Hydra parses overrides.
                    value = _hydra_value_as_override(value)
                argv.append(f&#34;{key}={value}&#34;)
        elif isinstance(arg, (list, tuple)):
            for part in arg:
                argv += self.value_to_argv(part)
        else:
            raise ValueError(f&#34;Can only process dict, tuple, lists and str, but got {arg}&#34;)
        return argv

    def get_name_parts(self, xp: XP) -&gt; OrderedDict:
        parts = OrderedDict()
        assert xp.delta is not None
        for name, value in xp.delta:
            parts[name] = value
        return parts

    def _main(self):
        if is_xp():
            run_dir = f&#34;hydra.run.dir={get_xp().folder}&#34;
            sys.argv.append(run_dir)
        try:
            return hydra.main(
                config_name=self.config_name,
                config_path=self.config_path,
                **self.hydra_kwargs)(self.main)()
        finally:
            if is_xp():
                sys.argv.remove(run_dir)

    def _get_config_groups(self) -&gt; tp.List[str]:
        with initialize_config_dir(str(self.full_config_path), job_name=self._job_name,
                                   **self.hydra_kwargs):
            gh = GlobalHydra.instance().hydra
            assert gh is not None
            return list(gh.list_all_config_groups())

    def _is_active(self, argv: tp.List[str]) -&gt; bool:
        if &#39;-m&#39; in argv or &#39;--multirun&#39; in argv:
            return False
        return True

    def _get_base_config(
            self, overrides: tp.List[str] = []
            ) -&gt; tp.Tuple[DictConfig, tp.List[tp.Tuple[str, str]]]:
        &#34;&#34;&#34;
        Return base config based on composition, along with delta for the
        composition overrides.
        &#34;&#34;&#34;
        with initialize_config_dir(str(self.full_config_path), job_name=self._job_name,
                                   **self.hydra_kwargs):
            gh = GlobalHydra.instance().hydra
            assert gh is not None
            to_keep = []
            delta: tp.List[tp.Tuple[str, str]] = []
            for arg in overrides:
                for group in self._config_groups:
                    if arg.startswith(f&#39;{group}=&#39;):
                        to_keep.append(arg)
                        _, value = arg.split(&#39;=&#39;, 1)
                        delta = [(g, v) for g, v in delta if g != group]
                        delta.append((group, value))
            if not to_keep:
                return self._base_cfg, []
            cfg = self._get_config_noinit(to_keep)
            return cfg, delta

    def _get_config(self,
                    overrides: tp.List[str] = []) -&gt; DictConfig:
        &#34;&#34;&#34;
        Internal method, returns the config for the given override,
        but without the dora.sig field filled.
        &#34;&#34;&#34;
        with initialize_config_dir(str(self.full_config_path), job_name=self._job_name,
                                   **self.hydra_kwargs):
            return self._get_config_noinit(overrides)

    def _get_config_noinit(self, overrides: tp.List[str] = []) -&gt; DictConfig:
        if old_hydra:
            with mock.patch.object(DictConfig, &#34;__deepcopy__&#34;, _no_copy):
                cfg = compose(self.config_name, overrides)  # type: ignore
            cfg = copy.deepcopy(cfg)
        else:
            cfg = compose(self.config_name, overrides)  # type: ignore
        return cfg

    def _get_delta(self, init: DictConfig, other: DictConfig):
        &#34;&#34;&#34;
        Returns an iterator over all the differences between the init and other config.
        &#34;&#34;&#34;
        delta = []
        for diff in _compare_config(init, other):
            name = &#34;.&#34;.join(diff.path)
            delta.append((name, diff.other_value))
        return delta


def hydra_main(config_name: str, config_path: str, **kwargs):
    &#34;&#34;&#34;Wrap your main function with this.
    You can pass extra kwargs, e.g. `version_base` introduced in 1.2.
    &#34;&#34;&#34;
    def _decorator(main: MainFun):
        return HydraMain(main, config_name=config_name, config_path=config_path,
                         **kwargs)
    return _decorator</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dora.hydra.hydra_main"><code class="name flex">
<span>def <span class="ident">hydra_main</span></span>(<span>config_name: str, config_path: str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrap your main function with this.
You can pass extra kwargs, e.g. <code>version_base</code> introduced in 1.2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hydra_main(config_name: str, config_path: str, **kwargs):
    &#34;&#34;&#34;Wrap your main function with this.
    You can pass extra kwargs, e.g. `version_base` introduced in 1.2.
    &#34;&#34;&#34;
    def _decorator(main: MainFun):
        return HydraMain(main, config_name=config_name, config_path=config_path,
                         **kwargs)
    return _decorator</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dora.hydra.HydraMain"><code class="flex name class">
<span>class <span class="ident">HydraMain</span></span>
<span>(</span><span>main: Callable, config_name: str, config_path: str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function that will actually run the XP, wrapped with tons of meta-informations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>main</code></strong> :&ensp;<code>callable, taking no argument</code></dt>
<dd>main function for the experiment as provided
by the user.</dd>
<dt><strong><code>dora</code></strong> :&ensp;<code>DoraConfig</code></dt>
<dd>configuration for Dora.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HydraMain(DecoratedMain):
    _slow = True

    def __init__(self, main: MainFun, config_name: str, config_path: str, **kwargs):
        self.config_name = config_name
        self.config_path = config_path
        self.hydra_kwargs = kwargs

        module = main.__module__
        if module == &#34;__main__&#34;:
            spec = sys.modules[module].__spec__
            if spec is None:
                module_path = sys.argv[0]
                self._job_name = module_path.rsplit(&#34;.&#34;, 2)[1]
            else:
                assert spec.origin is not None
                module_path = spec.origin
                module = spec.name
                self._job_name = module.rsplit(&#34;.&#34;, 1)[1]
        else:
            spec = find_spec(module)
            assert spec is not None and spec.origin is not None
            module_path = spec.origin
            self._job_name = module.rsplit(&#34;.&#34;, 1)[1]
        self.full_config_path = Path(module_path).parent.resolve()
        if config_path is not None:
            self.full_config_path = self.full_config_path / config_path

        self._initialized = False
        self._base_cfg = self._get_config()
        self._config_groups = self._get_config_groups()
        dora = self._get_dora()
        super().__init__(main, dora)
        # this is a really dirty hack to make Hydra believe that this is
        # coming from the __main__ module, as it would usually be.
        # This allows to use relative paths for config_path.
        main.__module__ = &#34;__main__&#34;

    def _get_dora(self) -&gt; DoraConfig:
        dora = DoraConfig()
        if hasattr(self._base_cfg, &#34;dora&#34;):
            update_from_hydra(dora, self._base_cfg.dora)
        dora.exclude += [&#34;dora.*&#34;, &#34;slurm.*&#34;]
        dora.dir = Path(dora.dir)
        return dora

    def get_slurm_config(self) -&gt; SlurmConfig:
        &#34;&#34;&#34;Return default Slurm config for the launch and grid actions.
        &#34;&#34;&#34;
        slurm = SlurmConfig()
        if hasattr(self._base_cfg, &#34;slurm&#34;):
            update_from_hydra(slurm, self._base_cfg.slurm)
        return slurm

    def get_xp(self, argv: tp.Sequence[str]):
        argv = _simplify_argv(argv)
        cfg = self._get_config(argv)
        base, delta = self._get_base_config(argv)
        delta += self._get_delta(base, cfg)
        xp = XP(dora=self.dora, cfg=cfg, argv=argv, delta=delta)
        return xp

    def value_to_argv(self, arg: tp.Any) -&gt; tp.List[str]:
        # Here we get the raw stuff from what is passed to the grid launcher.
        # arg is either a str (in which case it is a raw override)
        # or a dict, in which case each entry is an override,
        # or a list of dict or a list of str.
        argv = []
        if isinstance(arg, str):
            argv.append(arg)
        elif isinstance(arg, dict):
            for key, value in arg.items():
                if key not in self._config_groups:
                    # We need to convert the value using a custom function
                    # to respect how Hydra parses overrides.
                    value = _hydra_value_as_override(value)
                argv.append(f&#34;{key}={value}&#34;)
        elif isinstance(arg, (list, tuple)):
            for part in arg:
                argv += self.value_to_argv(part)
        else:
            raise ValueError(f&#34;Can only process dict, tuple, lists and str, but got {arg}&#34;)
        return argv

    def get_name_parts(self, xp: XP) -&gt; OrderedDict:
        parts = OrderedDict()
        assert xp.delta is not None
        for name, value in xp.delta:
            parts[name] = value
        return parts

    def _main(self):
        if is_xp():
            run_dir = f&#34;hydra.run.dir={get_xp().folder}&#34;
            sys.argv.append(run_dir)
        try:
            return hydra.main(
                config_name=self.config_name,
                config_path=self.config_path,
                **self.hydra_kwargs)(self.main)()
        finally:
            if is_xp():
                sys.argv.remove(run_dir)

    def _get_config_groups(self) -&gt; tp.List[str]:
        with initialize_config_dir(str(self.full_config_path), job_name=self._job_name,
                                   **self.hydra_kwargs):
            gh = GlobalHydra.instance().hydra
            assert gh is not None
            return list(gh.list_all_config_groups())

    def _is_active(self, argv: tp.List[str]) -&gt; bool:
        if &#39;-m&#39; in argv or &#39;--multirun&#39; in argv:
            return False
        return True

    def _get_base_config(
            self, overrides: tp.List[str] = []
            ) -&gt; tp.Tuple[DictConfig, tp.List[tp.Tuple[str, str]]]:
        &#34;&#34;&#34;
        Return base config based on composition, along with delta for the
        composition overrides.
        &#34;&#34;&#34;
        with initialize_config_dir(str(self.full_config_path), job_name=self._job_name,
                                   **self.hydra_kwargs):
            gh = GlobalHydra.instance().hydra
            assert gh is not None
            to_keep = []
            delta: tp.List[tp.Tuple[str, str]] = []
            for arg in overrides:
                for group in self._config_groups:
                    if arg.startswith(f&#39;{group}=&#39;):
                        to_keep.append(arg)
                        _, value = arg.split(&#39;=&#39;, 1)
                        delta = [(g, v) for g, v in delta if g != group]
                        delta.append((group, value))
            if not to_keep:
                return self._base_cfg, []
            cfg = self._get_config_noinit(to_keep)
            return cfg, delta

    def _get_config(self,
                    overrides: tp.List[str] = []) -&gt; DictConfig:
        &#34;&#34;&#34;
        Internal method, returns the config for the given override,
        but without the dora.sig field filled.
        &#34;&#34;&#34;
        with initialize_config_dir(str(self.full_config_path), job_name=self._job_name,
                                   **self.hydra_kwargs):
            return self._get_config_noinit(overrides)

    def _get_config_noinit(self, overrides: tp.List[str] = []) -&gt; DictConfig:
        if old_hydra:
            with mock.patch.object(DictConfig, &#34;__deepcopy__&#34;, _no_copy):
                cfg = compose(self.config_name, overrides)  # type: ignore
            cfg = copy.deepcopy(cfg)
        else:
            cfg = compose(self.config_name, overrides)  # type: ignore
        return cfg

    def _get_delta(self, init: DictConfig, other: DictConfig):
        &#34;&#34;&#34;
        Returns an iterator over all the differences between the init and other config.
        &#34;&#34;&#34;
        delta = []
        for diff in _compare_config(init, other):
            name = &#34;.&#34;.join(diff.path)
            delta.append((name, diff.other_value))
        return delta</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dora.main.DecoratedMain" href="main.html#dora.main.DecoratedMain">DecoratedMain</a></li>
<li><a title="dora.names.NamesMixin" href="names.html#dora.names.NamesMixin">NamesMixin</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dora.main.DecoratedMain" href="main.html#dora.main.DecoratedMain">DecoratedMain</a></b></code>:
<ul class="hlist">
<li><code><a title="dora.main.DecoratedMain.get_argv_from_sig" href="main.html#dora.main.DecoratedMain.get_argv_from_sig">get_argv_from_sig</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_name" href="names.html#dora.names.NamesMixin.get_name">get_name</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_name_parts" href="names.html#dora.names.NamesMixin.get_name_parts">get_name_parts</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_names" href="names.html#dora.names.NamesMixin.get_names">get_names</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_slurm_config" href="main.html#dora.main.DecoratedMain.get_slurm_config">get_slurm_config</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_xp" href="main.html#dora.main.DecoratedMain.get_xp">get_xp</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_xp_from_sig" href="main.html#dora.main.DecoratedMain.get_xp_from_sig">get_xp_from_sig</a></code></li>
<li><code><a title="dora.main.DecoratedMain.get_xp_history" href="main.html#dora.main.DecoratedMain.get_xp_history">get_xp_history</a></code></li>
<li><code><a title="dora.main.DecoratedMain.init_xp" href="main.html#dora.main.DecoratedMain.init_xp">init_xp</a></code></li>
<li><code><a title="dora.main.DecoratedMain.short_name_part" href="names.html#dora.names.NamesMixin.short_name_part">short_name_part</a></code></li>
<li><code><a title="dora.main.DecoratedMain.value_to_argv" href="main.html#dora.main.DecoratedMain.value_to_argv">value_to_argv</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dora" href="index.html">dora</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dora.hydra.hydra_main" href="#dora.hydra.hydra_main">hydra_main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dora.hydra.HydraMain" href="#dora.hydra.HydraMain">HydraMain</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>